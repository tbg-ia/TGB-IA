from flask import Flask, request, jsonify
import requests
import json
import logging
import os
from dotenv import load_dotenv

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler()
    ]
)

# Crear instancia de Flask
app = Flask(__name__)

# Configuración de OANDA API
API_URL = "https://api-fxtrade.oanda.com/v3"  # Asegúrate de que esta es la URL correcta para tu cuenta
API_KEY = os.getenv("OANDA_API_KEY")
ACCOUNT_ID = os.getenv("OANDA_ACCOUNT_ID")

# Configuración de Trailing Stop
TRAILING_STOP_PIPS = int(os.getenv("TRAILING_STOP_PIPS", 20))  # Valor por defecto 20 pips

# Validar configuración
if not API_KEY or not ACCOUNT_ID:
    logging.error("Las variables de entorno OANDA_API_KEY y OANDA_ACCOUNT_ID deben estar configuradas.")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
    exit(1)

# Definir el tamaño de un pip para GBP_USD
PIP_SIZE = 0.0001  # Para pares con 4 decimales como GBP_USD

def get_current_price(instrument):
    """
    Obtiene el precio actual para el instrumento especifica
    """
    endpoint = f"{API_URL}/accounts/{ACCOUNT_ID}/pricing"
    params = {
        "instruments": instrument
    }
    headers = {
        "Authorization": f"Bearer {API_KEY}"
    }

    try:
        response = requests.get(endpoint, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()
        prices = data.get("prices", [])
        if prices:
            bid = float(prices[0]['bids'][0]['price'])
            ask = float(prices[0]['asks'][0]['price'])
            mid_price = (bid + ask) / 2
            logging.info(f"Precio actual para {instrument}: {mid_price}")
            return mid_price
        else:
            logging.error(f"No se encontraron precios para {instrument}.")
            return None
    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred al obtener el precio: {http_err} - Respuesta: {response.text}")
    except Exception as e:
        logging.error(f"Error al obtener el precio: {e}")
    return None

def calculate_stop_loss(order_side, current_price, pips):
    """
    Calcula el precio del stop loss basado en la dirección de la orden y los pips.
    """
    distance = pips * PIP_SIZE
    if order_side.upper() == "BUY":
        stop_loss_price = current_price - distance
    elif order_side.upper() == "SELL":
        stop_loss_price = current_price + distance
    else:
        logging.error(f"Dirección de orden inválida: {order_side}")
        return None
    logging.info(f"Precio de Stop Loss calculado: {stop_loss_price}")
    return round(stop_loss_price, 5)  # Redondear a 5 decimales

def place_market_order(instrument, units, stop_loss_price=None):
    """
    Procesa una orden de mercado para un par de divisas, opcionalmente con un Stop Loss.
    """
    endpoint = f"{API_URL}/accounts/{ACCOUNT_ID}/orders"
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json",
    }

    # Detalles de la orden
    order_data = {
        "order": {
            "instrument": instrument,
            "units": int(units),
            "type": "MARKET",
            "positionFill": "DEFAULT",
        }
    }

    if stop_loss_price:
        order_data["order"]["stopLossOnFill"] = {
            "price": str(stop_loss_price)
        }

    try:
        response = requests.post(endpoint, headers=headers, data=json.dumps(order_data))
        response.raise_for_status()
        logging.info(f"Orden enviada: {order_data}")
        return response.json()
    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred: {http_err} - Respuesta: {response.text}")
    except Exception as e:
        logging.error(f"Error al enviar la orden: {e}")
    return None

def place_trailing_stop_order(instrument, side, pips):
    """
    Coloca una orden de Stop Loss 20 pips alejada del precio actual.

    Nota: Esta función coloca un Stop Loss inicial. Para un verdadero Trailing Stop,
    se requeriría un proceso en segundo plano que monitoree el movimiento del precio y ajuste el Stop Loss en consecuencia.
    """
    current_price = get_current_price(instrument)
    if current_price is None:
        logging.error("No se pudo obtener el precio actual. No se colocará el Trailing Stop.")
        return {"status": "error", "message": "No se pudo obtener el precio actual."}

    stop_loss_price = calculate_stop_loss(side, current_price, pips)
    if stop_loss_price is None:
        return {"status": "error", "message": "Error al calcular el Stop Loss."}

    # Colocar la orden de mercado con Stop Loss
    # Determinar unidades según el lado de la orden
    units = 100 if side.upper() == "BUY" else -100

    order_response = place_market_order(instrument, units, stop_loss_price)
    if order_response:
        logging.info("Trailing Stop colocado exitosamente.")
        return {"status": "success", "message": "Trailing Stop colocado exitosamente.", "order_details": order_response}
    else:
        logging.error("Error al colocar el Trailing Stop.")
        return {"status": "error", "message": "Error al colocar el Trailing Stop."}

@app.route('/webhook', methods=['POST'])
def webhook():
    """
    Recibe solicitudes POST en el webhook para procesar órdenes BUY o SELL.
    """
    try:
        data = request.get_json()
        logging.info(f"Solicitud recibida: {data}")

        # Validar datos recibidos
        if not data:
            logging.error("No se recibieron datos en la solicitud.")
            return jsonify({"error": "No se recibieron datos"}), 400

        comment = data.get('comment')
        received_account_id = data.get('ACCOUNT_ID')

        if not comment or not received_account_id:
            logging.error("Faltan 'comment' o 'ACCOUNT_ID' en la solicitud.")
            return jsonify({"error": "Faltan 'comment' o 'ACCOUNT_ID'"}), 400

        # Normalizar el ACCOUNT_ID recibido y esperado
        received_account_id = received_account_id.strip().lstrip('0')
        expected_account_id = ACCOUNT_ID.strip().lstrip('0')

        # Registrar ACCOUNT_ID recibido y esperado para depuración
        logging.info(f"Received ACCOUNT_ID: {received_account_id}")
        logging.info(f"Expected ACCOUNT_ID: {expected_account_id}")

        # Validar ACCOUNT_ID
        if received_account_id != expected_account_id:
            logging.error("ID de cuenta no coincide.")
            return jsonify({"error": "ID de cuenta no coincide"}), 403

        # Determinar acción según el comentario
        if comment.upper() in ["BUY", "SELL"]:
            side = comment.upper()
            instrument = "GBP_USD"

            # Colocar la orden de mercado con Trailing Stop de 20 pips
            trailing_stop_response = place_trailing_stop_order(instrument, side, TRAILING_STOP_PIPS)

            if trailing_stop_response["status"] == "success":
                return jsonify({
                    "message": f"Orden {side} ejecutada exitosamente",
                    "order_details": trailing_stop_response["order_details"]
                }), 200
            else:
                return jsonify({
                    "error": trailing_stop_response["message"]
                }), 500
        else:
            logging.error("Comando no reconocido en la solicitud.")
            return jsonify({"error": "Comando no reconocido"}), 400

    except Exception as e:
        logging.error(f"Error en el webhook: {e}")
        return jsonify({"error": "Error interno del servidor"}), 500